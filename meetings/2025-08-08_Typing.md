# Typing: Covariance & Contravariance

- Great Blog post by Marco: [Escaping Contravariance Hell](https://labs.quansight.org/blog/escaping-contravariance-hell)
- Narwhals specific notes from dangotbanned (the Typing expert) https://github.com/narwhals-dev/narwhals/blob/a8b89fd268f2031b52dfe0548e728fcacbc90a04/narwhals/_translate.py

---

For the below examples, copy/paste them into the [mypy playground](https://mypy-play.net/)

Some examples from Michele (https://github.com/ym-pett/practice-ground/blob/main/covariance_contravariance_invariance.ipynb)

# Covariance

`Specific instead of generic`

"You're using **something specific**, e.g. a an oyster knife for cutting carrots, where we'd **normally us something more generic**, i.e. a kitchen knife"

The code below passes because Tuple is covariant. The cell after fails because lists are invariant



to see the code run, https://mypy-play.net/?mypy=latest&python=3.12&gist=ac83c869bb0acec338fb4324d16ccb63

```python
from typing import Tuple, List
class Animal: pass
class Cat(Animal): pass

cats: Tuple[Cat, ...]
animals: Tuple[Animal, ...] = cats  # OK: Tuple is covariant

```

```python
cat_list: List[Cat]

animal_list: List[Animal]

animal_list = cat_list
```

<!-- #region -->
mypy output for above:


main.py:12: error: Incompatible types in assignment (expression has type "list[Cat]", variable has type "list[Animal]")  [assignment]

main.py:12: note: "list" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance

main.py:12: note: Consider using "Sequence" instead, which is covariant

Found 1 error in 1 file (checked 1 source file)

<!-- #endregion -->

# Contravariance

`Generic instead of specific`

"You're using something generic, where we usually have something more specific. E.g. a knife instead of an oyster knife for opening oysters."

The code below runs because functions are generally contravariant.

see the code run https://mypy-play.net/?mypy=latest&python=3.12&gist=8843ce89f7d049d756eac5c60130f23d


## Contravariance working:

```python
from typing import Callable
from typing import Tuple, List
class Animal: pass
class Cat(Animal): pass

def eat(animal: Animal) -> None: ...
def bark(dog: Cat) -> None: ...
action: Callable[[Animal], None]
my_action: Callable[[Cat], None] = action  # OK: Callable is contravariant in its argument

#TODO: break this with a function assignment that isn't contravariant
```

## Contravariance breaking:


another example I find easier to break & fix, adapted from Marco's tutorial https://labs.quansight.org/blog/escaping-contravariance-hell

the code below gives the message with the typical Liskov substitution violation for contravariance

"main.py:10: error: Argument 1 of "stroke" is incompatible with supertype "AnimalStroker"; supertype defines the argument type as "Animal"  [override]
main.py:10: note: This violates the Liskov substitution principle
main.py:10: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
Found 1 error in 1 file (checked 1 source file)"

see the code run: https://mypy-play.net/?mypy=latest&python=3.12&gist=867591a445d64b6b519bb4403815bcb1

```python
class Animal: ...
class Cat(Animal): ...
class Dog(Animal): ...

class AnimalStroker(Animal):
    def stroke(self, animal: Animal) -> None:
        ...
        
class DogStroker(AnimalStroker):
    def stroke(self, animal: Dog) -> None:
        ...
```

## How to fix the contravariance error: 

run code here:  https://mypy-play.net/?mypy=latest&python=3.12&gist=82c80b749ae6a50d6c1619fbf795b560

```python
from typing import TypeVar, Generic


class Animal: ...
class Cat(Animal): ...
class Dog(Animal): ...

AnimalT = TypeVar('AnimalT', bound=Animal)

class AnimalStroker(Generic[AnimalT]):
    def stroke(self, animal: AnimalT) -> None:
        ...
        
class DogStroker(AnimalStroker[Dog]):
    def stroke(self, animal: Dog) -> None:
        ...
```


### Using Protocol

run code here: https://mypy-play.net/?mypy=latest&python=3.12&gist=90a0bb6a7f26a1c427de8541227b9f4d

```python
from typing import Protocol, TypeVar

class Animal(Protocol): ...
class Cat(Animal): ...
class Dog(Animal): ...

AnimalT = TypeVar('AnimalT', bound=Animal)

class AnimalStroker(Protocol[AnimalT]):
    def stroke(self, animal: AnimalT) -> AnimalT:
        ...
        
class DogStroker(AnimalStroker[Dog]):
    def stroke(self, animal: Dog) -> Dog:
        return animal

```

Note how in the solution above, I had to specify a return type and give `DogStroker.stroke` a return statement.

If I didn't have these, I had to specify `contravariant=True` for `TypeVar`. Why is that? 

### How I got it working without return arguments

run code here: https://mypy-play.net/?mypy=latest&python=3.12&gist=86b2888808e9f684a040f8b86cf08ca7

```python
from typing import Protocol, TypeVar

class Animal(Protocol): ...
class Cat(Animal): ...
class Dog(Animal): ...

AnimalT = TypeVar('AnimalT', bound=Animal, contravariant=True)

class AnimalStroker(Protocol[AnimalT]):
    def stroke(self, animal: AnimalT) -> None:
        ...
        
class DogStroker(AnimalStroker[Dog]):
    def stroke(self, animal: Dog) -> None:
        ...
```

### Invariance - WIP

`Like for Like`

Lists & dictionaries are invariant as they are mutable containers


### Patterns - WIP


- Covariance is useful for immutable (read-only) containers.
- Contravariance is used for argument types in callables (functions).
- Invariance is the default for most mutable containers to avoid subtle bugs.

---

Some examples from Cameron

```python
from typing import Tuple, Callable, List

class Shape: pass
class Circle(Shape): pass
class Square(Shape): pass


a: Shape = Circle()
b: Circle = Shape() # expected a Circle, got a Shape; assignments take the same type or "more specific"


def f(s: Shape) -> None: pass # function will do something with a Shape
f(Shape())
f(Circle()) # just like assignments we can pass something "more specific"
            # this implies that our function `f` is prepared to handle ANY Shape (keep this in mind)

def g(c: Circle) -> None: pass # function will do something with a Circle
g(Shape())                     # what we do with a Circle we can't do with any plain ol' Shape
g(Circle())

def h(func: Callable[[Shape], None]) -> None: pass # now we have a function that takes a function;
                                                   # similar to the above, the passed function must be able to handle ANY Shape
h(f)
h(g) # does not work; the passed function can only handle Circles! We need a function that can handle ANY Shape

def z(o: object) -> None: pass
h(z) # works! If your function can handle any arbitrary object, it definitionally should be able to handle any shape as well.
```
